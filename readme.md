# Python DSP

This project contains hands-on applications for various DSP related topics.
Examples of audio processing, noise reduction and basic concepts of signal process can be found here.
Also this repository contains a documentation tool that is very useful to keep new algorithms, discoveries or general signal processing theory (or any other information really) at hand.  

### **Python DSP is the ultimate Digital Signal Processing learning tool!**

### Usage

The Python version supported by this project is **3.10**.

Each folder has a requirements.txt. To install the necessary modules run:

```
pip install -r requirements.txt
```

### Future Improvements

* Finish Encyclopedia subcontent display handler
* Use pyTxtPad to create the Encyclopedia texts
* Optimize real time process to run in higher frequencies
* Implement search feature onto Encyclopedia
* Clean and improve data files

## Table of contents

* [Data](#data)
* [Encyclopedia](#encyclopedia)
* [Libraries](#libraries)
* [Algorithms](#algorithms)

## Data

The data folder contains various data files that are used with different signal processing fields.
They should be used as reference without editing them or creating new output files on this folder.

### Audio Files

This folder contains various audio samples to be used as input for different DSP implementations.
They can be divided in 3 categories:
* Speech files: intended to be used with techniques like noise reduction or speech enhancement
* Music files: should be used with music related algorithms, like stereo widening or equalizer
* Theoretical files: simple files generated by algorithm to prove basic DSP theory

### IMU Files

Log files collected using an Inertial Motion Unit sensor. These files are intended to be used with algorithms like gesture recognition.

## Encyclopedia

Easy way to search and collect information about pertinent DSP algorithms. This content will be read from YAML source files which text data can be added in any order. The idea is to summarize and create an encyclopedia with all important DSP concepts in one organized place that can be referenced easier than a single book or a online search. The contents can contain any pure text data. Ideally with link for references. The best part is that this data will be stored in the same repo as the demonstration codes. That means only by accessing the repo all the resources are there. The library application will be entire accessed with the terminal and won't use any GUI for usage.

*The YAML files should be stored within the Encyclopedia folder under the Data folder.*

### Features

The search engine will sort subjects automatically by:
* Alphabetical order
* Date modified
* Category alphabetical order

The user can make custom search by:
* Letters: search any amount of letters that matches title + contents
* Keywords: search in title + contents
* Date modified: using start to end date

The user can also add additional chapters inside each subject that will be used as index. The user than can access them individually otherwise their contents will be omitted when the main subject is accessed.

### Data structure

The data structure used will be YAML due to its similarity to Python indexation use. Here is an example of usage:

```
#Subject name
Polyphase quadrature filter:
  #Main category        
	category: "Filters"
  #Subcategory field
  subcategory: "FIR"
  #YYYY/MM/DD   
	date: "2021/05/04"
  #List or single string
	links: "https://en.wikipedia.org/wiki/Polyphase_quadrature_filter" 
  # |- added to keep the newlines
	contents: |-
     A polyphase quadrature filter, or PQF, is a filter bank which 
     splits an input signal into a given number N (mostly a 
     power of 2) of equidistant sub-bands. 
  # Can have any size of components
  subcontents:
     Applications: Compression, decimation and interpolation
     Comercial Usage: MP3	
```

General rules:
* The names "category","date","links","contents" and "subcontents" are mandatory and other names will be ignored
* No field is mandatory for the code to work. Non complete fields will be set as "Null" in the search
* Only contents will be displayed, the other fields will be used as metadata unless user requests more info

	
## Libraries

Python Libraries created to be used standalone or included within other Python applications.
The libraries can be divided in:

### Fixed Point Library

This function provides the same solution as ML's fi command. The difference is that the output can actually be printed in the screen rather than creating an object. This function also have the option to return a list of values with the desired type of conversion. This function also provide error tracing, showing the values that are not corrected input for the configuration set by the user. The first value display will be in the input format.

#### Usage

This code can be used 2 ways:
* As a library by adding the following line in your code

```
					  from fi import fi
```

Note: remember to have this file in the same folder as the file you will be calling fi function from

* As a standalone conversion code. Hence you can run this code using command line like shown below:

```
						python fi.py
```

Note: remember to have terminal/prompt opened in the same folder as this file

#### Parameters

* Values: The input values of the function.
	* The input is a PYTHON LIST of any size (can accept also one INT or FLOAT)
	* For dec to hex or bin conversion the values need to be in dec format and for hex or bin to dec conversion values need to be bigger than 1
* Signed: Check if the value is signed (1) or unsigned (0)
* TotalLen: The total number of bits used
* FracLen: The number of bits used to represent the fractional part
* Format: Check if the input is decimal (1) or hex/bin (0)
* ReturnVal: Check if the function returns value or just prints
	* "None": returns None, only prints values
	* "Dec" : returns a list of decimal values
	* "Hex" : returns a string of hex values
	* "Bin" : returns a string of bin values

### Real Time Library

This library provides an easy solution to apply new algorithms with no need to stress with the frame overlap for that. 

There are different functions depending in the data input:

#### wave_file_process

Function reads a wave file and call the processing functions entered by the user
User can return the process data or save it in an wav file

* Params
    * in_file_name: the wave file name (with full directory)
    * get_file_details: returns the wav file details in form of dictionary with keys name, samplerate, channels, length_samples, length_seconds and data_type
    * out_file_name: the output wav file name. If empty will return processed data in python list format.  
    * stereo: True for stereo, False for mono (left will be used for mono). If the input file is mono, left data will be copied to right.
    * overlap: 50% (50) or 75% (75) overlap options
    * block_size: The number of input samples per frame
    * zero_pad: Add nff/2 zeros in each frame, reducing by half the input frame of the system. For example, if overlap is 50% and NFFT is 256 point, each time domain frame will have 64 new samples per loop if zero pad is True and 128 if zero pad is False.
    * pre_proc_func: The time domain preprocess function
        * Inputs: The current time domain frames 
        * Output: Should return the same object as the input with processed data
        * Format: Python list of float objects ([1,2,3...] for mono [[1,2,3..][1,2,3..]] for stereo)
    * freq_proc_func: The frequency domain process function
        * Inputs: The current frequency domain frames with real and imaginary components of size (nfft/2)+1 (non normalized) 
        * Output: Should return the same object as the input with processed data
        * Format: Python list of numpy.complex128 objects ([1,2,3...] for mono [[1,2,3..][1,2,3..]] for stereo)
    * post_proc_func: The time domain postprocess function
        * Inputs: The current time domain frames 
        * Output: Should return the same object as the input with processed data
        * Format: Python list of float objects ([1,2,3...] for mono [[1,2,3..][1,2,3..]] for stereo)

#### real_time_stream

Function captures and stream data in real time from the device mic and speaker.

* Params
	* device: a tuple with the input and output devices number. Use the command "python3 -m sounddevice" to check the devices available
	* samplerate: the sampling frequency for the audio stream
	* stereo: True for stereo, False for mono (left will be used for mono)
	* overlap: 50% (50) or 75% (75) overlap options
	* block_size: The number of input samples per frame
	* zero_pad: Add nff/2 zeros in each frame, reducing by half the input frame of the system. For example, if overlap is 50% and NFFT is 256 point, each time domain frame will have 64 new samples per loop if zero pad is True and 128 if zero pad is False.
	* pre_proc_func: The time domain preprocess function
        * Inputs: The current time domain frames 
        * Output: Should return the same object as the input with processed data
        * Format: Python list of float objects ([1,2,3...] for mono [[1,2,3..][1,2,3..]] for stereo)
    * freq_proc_func: The frequency domain process function
        * Inputs: The current frequency domain frames with real and imaginary
                components of size (nfft/2)+1 (non normalized) 
        * Output: Should return the same object as the input with processed data
        * Format: Python list of numpy.complex128 objects ([1,2,3...] for mono [[1,2,3..][1,2,3..]] for stereo)
    * post_proc_func: The time domain postprocess function
        * Inputs: The current time domain frames 
        * Output: Should return the same object as the input with processed data
        * Format: Python list of float objects ([1,2,3...] for mono [[1,2,3..][1,2,3..]] for stereo)

NOTE: Current the limitation is only samplerate 16kHz or below

### Helper Libraries
In this category there are the libraries:
* Z plane: useful tool to plot unitary circle Z plane along with poles and zeros
* Progress bar: used to print process progress onto the terminal

## Algorithms

The algorithms folder contain various standalone applications demonstrating a real world example for different signal processing techniques (aka algorithms). All files have a explanatory header about the algorithm itself and the script usage.

### Examples

* [Comb Filter](Algorithms/comb_filter.py)
* [Double Integration](Algorithms/double_integration.py)
* [Exponential Moving Average Filter](Algorithms/ema_filter.py)
* [IIR Filter Application](Algorithms/filter_application.py)
* [IIR Filter Design](Algorithms/filter_application.py)
* [Stereo Enhancement (Mid-side)](Algorithms/mid_side.py)
* [Noise Reduction with Voice Activity Detection](Algorithms/noise_reduction_with_vad.py)
* [Tinnitus Treatment](Algorithms/tinnitus_treatment.py)
* [Wave Generation](Algorithms/wave_generation.py)
* [Pseudo Random Number Generator](Algorithms/white_noise.py)

### Documentation

Complementary documentation related to different algorithms. They can be output results, references, external links and so on.
